# 总持续时间可被 60 整除的歌曲

## 题目
在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字 i 和 j 满足  i < j 且有 (time[i] + time[j]) % 60 == 0。

示例1:
``` JS
输入：[30,20,150,100,40] 输出：3
解释：这三对的总持续时间可被 60 整数：
(time[0] = 30, time[2] = 150): 总持续时间 180
(time[1] = 20, time[3] = 100): 总持续时间 120
(time[1] = 20, time[4] = 40): 总持续时间 60
```

示例 2：
``` JS
输入：[60,60,60] 输出：3
解释：所有三对的总持续时间都是 120，可以被 60 整数。
```

提示:
``` JS
1 <= time.length <= 60000
1 <= time[i] <= 500
```

## 我的思路
暴力两层循环
遍历循环, time[0] 时, 循环余下所有元素找出可以相加后被 60 整除的元素, 之后在找 time[1] 的, 依次这么遍历.

缺点: 时间负责度为 O(n^2)

## 更好的思路

利用余数: 时间复杂度 O(n)

1. 对整数取模，我们知道 num%60 结果一定是<=59,首先创建一个长度为60的数组来存储余数出现的次数。

2. 然后遍历 time, 对每个元素 %60 计算，把结果放到对应的数组 array 的索引下。例如70%60=10，就把arr[10]+=1,就是说余数是10的出现一次并做累加操作。

3. 遍历得出每个余数出现的次数, 对 余数 0 和 30 做特殊处理, 剩下的遍历 (1~29), 如果 余数 i = 10, 出现次数为1, 此时只要知道余数(60 - 10)出现的次数,就能得到余数为 10 和 50 的两个数能被 60 整除的对数.

4. 对 余数 0 和 30中, 需要找到的是**两两且不重复组合 C(n, 2)**, 计算公式为 `n*(n-1)/2`